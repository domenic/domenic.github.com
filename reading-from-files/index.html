<!DOCTYPE html>
<meta charset="utf-8">
<title>Reading from Files</title>


<meta name="author" content="Domenic Denicola">
<meta name="description" content="This post is part of a series on the byte sources underlying the readable streams in the Streams Standard. See the introductory post for more &hellip;">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="canonical" href="https://blog.domenic.me/reading-from-files/">
<link rel="alternate" href="/atom.xml" title="Hidden Variables" type="application/atom+xml">
<link rel="icon" href="/favicon.png">

<link rel="stylesheet" href="/stylesheets/screen.css">
<script src="/javascripts/ender.js"></script>
<script src="/javascripts/octopress.js"></script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic">



<meta name="twitter:card" content="summary">
<meta name="twitter:creator" content="@domenic">
<meta property="og:title" content="Reading from Files">
<meta property="og:description" content="This post is part of a series on the byte sources underlying the readable streams in the Streams Standard. See the introductory post for more background and links to the rest of the series. Once you have opened a file descriptor, you&rsquo;ll use &hellip;">

<script>
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-37626687-1']);
_gaq.push(['_trackPageview']);

(function() {
  var ga = document.createElement('script');
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  document.body.appendChild(ga);
})();
</script>



<body   >

<header><hgroup>
  <h1><a href="/">Hidden Variables</a></h1>
  <h2>Domenic's blog about coding and stuff</h2>
</hgroup>

</header>
<nav><a class="subscription" href="/atom.xml" rel="subscribe-rss" title="Subscribe via RSS">RSS</a>
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:blog.domenic.me" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/archives/">Archives</a></li>
</ul>

</nav>
<div id="main">
<div id="content">
  <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">Reading from Files</h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-03-05T00:00:00+00:00" pubdate data-updated="true">Mar 5<sup>th</sup>, 2015</time>
        
         | <a href="#disqus_thread">Comments</a>
        
      </p>
    
  </header>


<div class="entry-content"><p><em>This post is part of a series on the byte sources underlying the readable streams in the Streams Standard. See <a href="/byte-sources-introduction/">the introductory post</a> for more background and links to the rest of the series.</em></p>

<p>Once you have opened a file descriptor, you&rsquo;ll use the <a href="http://linux.die.net/man/2/read">read(2)</a> function to read bytes from it. In C the signature is</p>

<figure class='code'><figcaption><span></span></figcaption><pre class='highlight'><code class='c'><span class="kt">ssize_t</span> <span class="nf">read</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">);</span>
</code></pre></figure>

<p>Translated into JavaScript this might look something like</p>

<figure class='code'><figcaption><span></span></figcaption><pre class='highlight'><code class='js'><span class="kr">const</span> <span class="nx">bytesRead</span> <span class="o">=</span> <span class="nx">file</span><span class="p">.</span><span class="nx">readInto</span><span class="p">(</span><span class="nx">buffer</span><span class="p">,</span> <span class="nx">offset</span><span class="p">,</span> <span class="nx">count</span><span class="p">);</span>
</code></pre></figure>

<p>which will attempt to read <code>count</code> bytes into the <code>ArrayBuffer</code> <code>buffer</code>, starting at position <code>offset</code> into the <code>ArrayBuffer</code>. The returned number of bytes, <code>bytesRead</code>, might be less than the desired <code>count</code>, usually because you&rsquo;ve reached the end of the file.</p>

<p>The most interesting thing to note about read(2) is that it is blocking. So our above naive translation into JavaScript would actually lock up your browser or server for the amount of time the I/O happens. This is obviously a no-go if you&rsquo;re trying to write a server that serves more than one user in parallel, or trying to create a responsive 60 fps web page.</p>

<p>But of course we know how to fix this. We&rsquo;ll just turn it into a promise-returning function:</p>

<figure class='code'><figcaption><span></span></figcaption><pre class='highlight'><code class='js'><span class="nx">file</span><span class="p">.</span><span class="nx">readInto</span><span class="p">(</span><span class="nx">buffer</span><span class="p">,</span> <span class="nx">offset</span><span class="p">,</span> <span class="nx">count</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="nx">bytesRead</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="p">...</span> <span class="p">});</span>
</code></pre></figure>

<p>Not so fast. How exactly do we plan on translating a blocking POSIX API into a non-blocking JavaScript API? The obvious answer is to use another thread. That is, off in a background thread, we pass the memory represented by <code>buffer</code> into read(2), and when read(2) finishes, we go back to the main thread and fulfill the promise we previously vended with read(2)&rsquo;s return value.</p>

<p>This solution has a major issue, however: <strong>data races</strong>. That is, it makes it possible to observe the memory in <code>buffer</code> changing out from under us, with code like the following:</p>

<figure class='code'><figcaption><span></span></figcaption><pre class='highlight'><code class='js'><span class="kr">const</span> <span class="nx">view</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Uint8Array</span><span class="p">(</span><span class="nx">buffer</span><span class="p">);</span>
<span class="nx">file</span><span class="p">.</span><span class="nx">readInto</span><span class="p">(</span><span class="nx">buffer</span><span class="p">,</span> <span class="nx">offset</span><span class="p">,</span> <span class="nx">count</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="nx">bytesRead</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="p">...</span> <span class="p">});</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">view</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">===</span> <span class="nx">view</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</code></pre></figure>

<p>Because the memory in <code>buffer</code> is being filled in by read(2) in the background thread, it&rsquo;s possible for this program to output <code>false</code>! Oh no!</p>

<p>In the io.js world, this is considered OK, and with some effort you can create situations like this using their native <code>Buffer</code> type. However, in the world of web browsers, and in general in any world where standards bodies need to get multiple vendors to agree, this is not going to fly. JavaScript&rsquo;s execution model is strongly based around a run-to-completion single-threaded paradigm, and if we poke holes in that by letting other threads modify our variables out from under us between two execution steps, all hell can break lose. No specs, libraries, or optimizing compilers are written to accomodate such a world.</p>

<p>One proposed solution would be to <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer/transfer"><em>transfer</em></a> the backing memory of the <code>ArrayBuffer</code> into a new <code>ArrayBuffer</code> that is only accessible once the read(2) call has finished. In code, that might look something like this:</p>

<figure class='code'><figcaption><span></span></figcaption><pre class='highlight'><code class='js'><span class="nx">file</span><span class="p">.</span><span class="nx">readInto</span><span class="p">(</span><span class="nx">buffer</span><span class="p">,</span> <span class="nx">offset</span><span class="p">,</span> <span class="nx">count</span><span class="p">).</span><span class="nx">then</span><span class="p">(({</span> <span class="nx">result</span><span class="p">,</span> <span class="nx">bytesRead</span> <span class="p">})</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="c1">// `result` is backed by the same memory `buffer` used to be</span>
  <span class="c1">// backed by, but they are not equal:</span>
  <span class="nx">assert</span><span class="p">(</span><span class="nx">result</span> <span class="o">!==</span> <span class="nx">buffer</span><span class="p">);</span>
<span class="p">});</span>

<span class="c1">// `buffer`&#39;s backing memory has now been transferred, so trying to use</span>
<span class="c1">// `buffer` directly (or any views onto `buffer`) will throw:</span>
<span class="nx">assert</span><span class="p">.</span><span class="kr">throws</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">buffer</span><span class="p">.</span><span class="nx">byteLength</span><span class="p">);</span>
<span class="nx">assert</span><span class="p">.</span><span class="kr">throws</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="k">new</span> <span class="nx">Uint8Array</span><span class="p">(</span><span class="nx">buffer</span><span class="p">));</span>
</code></pre></figure>

<p>Note how once <code>buffer</code> has been transferred, the <code>buffer</code> instance itself is now useless: it is &ldquo;detached&rdquo; in spec terms.</p>

<p>We could also imagine other ways of avoiding the data races. For example, if we had an API that allowed the background thread to first detach, then &ldquo;reattach,&rdquo; the backing memory to <code>buffer</code>, we wouldn&rsquo;t need the separate <code>buffer</code> and <code>result</code> variables pointing to the same backing memory. Ideally such an API would allow us to detach and reattach <em>sections</em> of the <code>ArrayBuffer</code>, so that I could (for example) read multiple files in parallel into different sections of one large buffer. <a href="https://esdiscuss.org/topic/improving-detachment-for-array-buffers">I proposed this on es-discuss</a>, but nobody seemed to be interested.</p>

<p>Alternately, we could decide that for a low-level JavaScript API representing a file descriptor, data races are OK after all. In that case, <a href="https://blog.mozilla.org/javascript/2015/02/26/the-path-to-parallel-javascript/">Mozilla&rsquo;s <code>SharedArrayBuffer</code> proposal</a> would be a good fitâ€”we&rsquo;ll just write to the shared array buffer in the background thread, while still allowing reading in the main thread. As mentioned before, it might be hard to get such a primitive past multiple vendors and into the relevant standards. But the desire to transpile threaded C and C++ code into asm.js is proving to be a powerful motivator, which might push it into acceptance.</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Domenic Denicola</span></span>

      








  


<time datetime="2015-03-05T00:00:00+00:00" pubdate data-updated="true">Mar 5<sup>th</sup>, 2015</time>
      

<span class="categories">
  
    <a class='category' href='/categories/streams/'>streams</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  <a href="http://twitter.com/share" class="twitter-share-button" data-url="https://blog.domenic.me/reading-from-files/" data-via="domenic" data-counturl="https://blog.domenic.me/reading-from-files/" >Tweet</a>
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/byte-sources-introduction/" title="Previous Post: Byte Sources: Introduction">&laquo; Byte Sources: Introduction</a>
      
      
        <a class="basic-alignment right" href="/reading-from-sockets/" title="Next Post: Reading from Sockets">Reading from Sockets &raquo;</a>
      
    </p>
  </footer>
</article>

  <section>
    <h1>Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
  </section>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/reading-from-sockets/">Reading from Sockets</a>
      </li>
    
      <li class="post">
        <a href="/reading-from-files/">Reading from Files</a>
      </li>
    
      <li class="post">
        <a href="/byte-sources-introduction/">Byte Sources: Introduction</a>
      </li>
    
      <li class="post">
        <a href="/the-revealing-constructor-pattern/">The Revealing Constructor Pattern</a>
      </li>
    
      <li class="post">
        <a href="/continual-progress-in-the-w3c-tag/">Continual Progress in the W3C TAG</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/domenic">@domenic</a> on GitHub
  
  <script type="text/javascript">
    $.domReady(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'domenic',
            count: 5,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>





  
</aside>


</div>
</div>
<footer><p>
  Copyright &copy; 2015 - Domenic Denicola -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>


<script>
  var disqus_shortname = 'hiddenvariables';
  
    
    // var disqus_developer = 1;
    var disqus_identifier = 'https://blog.domenic.me/reading-from-files/';
    var disqus_url = 'https://blog.domenic.me/reading-from-files/';
    var disqus_script = 'embed.js';
  
(function () {
  var dsq = document.createElement('script');
  dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
  document.body.appendChild(dsq);
}());
</script>






<script>
(function(){
  var twitterWidgets = document.createElement('script');
  twitterWidgets.src = '//platform.twitter.com/widgets.js';
  document.body.appendChild(twitterWidgets);
})();
</script>




